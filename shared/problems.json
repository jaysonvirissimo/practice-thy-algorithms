{
  "two_sum": {
    "title": "Two Sum",
    "description": "Implement a function that locates a pair of elements within an integer array whose sum equals a specified target value. The function should return the array indices of these two elements. Assume exactly one valid pair exists and that no element may be used twice in the solution.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "array",
        "type": "array<integer>",
        "description": "Array of integers"
      },
      {
        "name": "target",
        "type": "integer",
        "description": "Target sum"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function twoSum(nums, target)",
      "ruby": "def two_sum(nums, target)",
      "python": "def two_sum(nums, target)"
    },
    "testCases": [
      {
        "input": {
          "nums": [2, 7, 11, 15],
          "target": 9
        },
        "expected": [0, 1],
        "description": "should return indices [0, 1] because nums[0] + nums[1] = 2 + 7 = 9"
      },
      {
        "input": {
          "nums": [3, 2, 4],
          "target": 6
        },
        "expected": [1, 2],
        "description": "should return indices [1, 2] because nums[1] + nums[2] = 2 + 4 = 6"
      },
      {
        "input": {
          "nums": [3, 3],
          "target": 6
        },
        "expected": [0, 1],
        "description": "should return indices [0, 1] because nums[0] + nums[1] = 3 + 3 = 6"
      }
    ]
  },
  "maximum_subarray": {
    "title": "Maximum Subarray",
    "description": "Design an algorithm to determine the maximum sum achievable from any contiguous subsequence within an array of integers. The array contains both positive and negative values. While a brute-force approach examining all possible subarrays runs in O(nÂ²) time, strive for an optimal O(n) solution using constant space.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "array",
        "type": "array<integer>",
        "description": "Array of integers (positive and negative)"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function maximumSubarray(numbers)",
      "ruby": "def maximum_subarray(array)",
      "python": "def maximum_subarray(array)"
    },
    "testCases": [
      {
        "input": {
          "array": [4, -1, 5, 6, -13, 2]
        },
        "expected": 14,
        "description": "should return the largest subsum"
      },
      {
        "input": {
          "array": [-2, 1, -3, 4, -1, 2, 1, -5, 4]
        },
        "expected": 6,
        "description": "should return the largest subsum"
      }
    ]
  },
  "unique_paths": {
    "title": "Unique Paths",
    "description": "Develop a recursive algorithm to count the total number of distinct shortest paths through a rectangular grid from the top-left corner to the bottom-right corner. Movement is restricted to rightward and downward steps only. Implement memoization to optimize the recursive solution and avoid redundant calculations.",
    "complexity": "O(m*n)",
    "parameters": [
      {
        "name": "rows",
        "type": "integer",
        "description": "Number of rows in the grid"
      },
      {
        "name": "columns",
        "type": "integer",
        "description": "Number of columns in the grid"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function uniquePaths(rows, columns)",
      "ruby": "def unique_paths(rows, columns)",
      "python": "def unique_paths(rows, columns)"
    },
    "testCases": [
      {
        "input": {
          "rows": 3,
          "columns": 7
        },
        "expected": 28,
        "description": "should return 28 unique paths for 3x7 grid"
      },
      {
        "input": {
          "rows": 4,
          "columns": 12
        },
        "expected": 364,
        "description": "should return 364 unique paths for 4x12 grid"
      },
      {
        "input": {
          "rows": 5,
          "columns": 15
        },
        "expected": 3060,
        "description": "should return 3060 unique paths for 5x15 grid"
      }
    ]
  },
  "coin_change": {
    "title": "Coin Change",
    "description": "Construct an algorithm that determines the minimum number of coins needed to make change for a given monetary amount. Given a set of coin denominations and a target amount, return an array containing the specific coins that sum to the target using the fewest possible coins. Implement this as a classic dynamic programming optimization problem.",
    "complexity": "O(amount * coins)",
    "parameters": [
      {
        "name": "amount",
        "type": "integer",
        "description": "Target monetary amount to make change for"
      },
      {
        "name": "coins",
        "type": "array<integer>",
        "description": "Available coin denominations (optional, defaults to [1, 5, 10, 25])"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function coinChange(amount, coins = [1, 5, 10, 25])",
      "ruby": "def coin_change(amount, coins = [1, 5, 10, 25])",
      "python": "def coin_change(amount, coins = [1, 5, 10, 25])"
    },
    "testCases": [
      {
        "input": {
          "amount": 36,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 10, 1],
        "description": "should return [25, 10, 1] using minimum 3 coins for 36 cents"
      },
      {
        "input": {
          "amount": 43,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 10, 5, 1, 1, 1],
        "description": "should return [25, 10, 5, 1, 1, 1] using minimum 6 coins for 43 cents"
      },
      {
        "input": {
          "amount": 67,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 25, 10, 5, 1, 1],
        "description": "should return [25, 25, 10, 5, 1, 1] using minimum 6 coins for 67 cents"
      }
    ]
  },
  "contains_duplicate": {
    "title": "Contains Duplicate",
    "description": "Analyze an integer array to determine whether any value appears more than once. Return true if at least one duplicate exists, false if all elements are distinct. Design an efficient solution that can handle arrays with up to 100,000 elements containing values in the range of negative one billion to positive one billion.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers to check for duplicates"
      }
    ],
    "returnType": {
      "javascript": "boolean",
      "ruby": "boolean",
      "python": "boolean"
    },
    "functionSignatures": {
      "javascript": "function containsDuplicate(nums)",
      "ruby": "def contains_duplicate(nums)",
      "python": "def contains_duplicate(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [1, 2, 3, 1]
        },
        "expected": true,
        "description": "should return true when element 1 appears at indices 0 and 3"
      },
      {
        "input": {
          "nums": [1, 2, 3, 4]
        },
        "expected": false,
        "description": "should return false when all elements are distinct"
      },
      {
        "input": {
          "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
        },
        "expected": true,
        "description": "should return true when multiple elements have duplicates"
      }
    ]
  },
  "best_time_to_buy_and_sell_stock": {
    "title": "Best Time to Buy and Sell Stock",
    "description": "Determine the optimal strategy for a single stock transaction to maximize profit. Given an array representing stock prices over consecutive days, identify the most profitable buy-sell pair where the purchase precedes the sale. The algorithm should find the maximum difference between a selling price and a buying price, with the constraint that the buying day must occur before the selling day. If no profitable transaction exists, return zero.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "prices",
        "type": "array<integer>",
        "description": "Array of stock prices where prices[i] represents the price on day i"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function maxProfit(prices)",
      "ruby": "def max_profit(prices)",
      "python": "def max_profit(prices)"
    },
    "testCases": [
      {
        "input": {
          "prices": [7, 1, 5, 3, 6, 4]
        },
        "expected": 5,
        "description": "should return 5 by buying at price 1 and selling at price 6"
      },
      {
        "input": {
          "prices": [7, 6, 4, 3, 1]
        },
        "expected": 0,
        "description": "should return 0 when prices only decrease"
      },
      {
        "input": {
          "prices": [1, 2, 3, 4, 5]
        },
        "expected": 4,
        "description": "should return 4 by buying at price 1 and selling at price 5"
      }
    ]
  },
  "valid_parentheses": {
    "title": "Valid Parentheses",
    "description": "Construct an algorithm to validate the proper matching and ordering of bracket characters within a string. Given a string containing only parentheses, square brackets, and curly braces, determine whether the brackets are correctly paired and nested. Each opening bracket must have a corresponding closing bracket of the same type, and brackets must be closed in the proper order to maintain valid nesting structure.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "s",
        "type": "string",
        "description": "String containing only bracket characters: '(', ')', '[', ']', '{', '}'"
      }
    ],
    "returnType": {
      "javascript": "boolean",
      "ruby": "boolean",
      "python": "boolean"
    },
    "functionSignatures": {
      "javascript": "function isValid(s)",
      "ruby": "def is_valid(s)",
      "python": "def is_valid(s)"
    },
    "testCases": [
      {
        "input": {
          "s": "()"
        },
        "expected": true,
        "description": "should return true for simple parentheses pair"
      },
      {
        "input": {
          "s": "()[]{}"
        },
        "expected": true,
        "description": "should return true for multiple bracket types in sequence"
      },
      {
        "input": {
          "s": "(]"
        },
        "expected": false,
        "description": "should return false for mismatched bracket types"
      },
      {
        "input": {
          "s": "([])"
        },
        "expected": true,
        "description": "should return true for properly nested brackets"
      },
      {
        "input": {
          "s": "([)]"
        },
        "expected": false,
        "description": "should return false for improperly nested brackets"
      }
    ]
  },
  "product_of_array_except_self": {
    "title": "Product of Array Except Self",
    "description": "Construct an algorithm that generates an output array where each element represents the product of all input array elements excluding the element at the current index position. The solution must operate in O(n) time complexity without utilizing division operations. Design the algorithm to handle arrays containing up to 10^5 elements with values ranging from -30 to 30, ensuring all intermediate and final products remain within 32-bit integer bounds.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers where each element contributes to products at other indices"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function productExceptSelf(nums)",
      "ruby": "def product_except_self(nums)",
      "python": "def product_except_self(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [1, 2, 3, 4]
        },
        "expected": [24, 12, 8, 6],
        "description": "should return [24, 12, 8, 6] where each element is the product of all others"
      },
      {
        "input": {
          "nums": [-1, 1, 0, -3, 3]
        },
        "expected": [0, 0, 9, 0, 0],
        "description": "should return [0, 0, 9, 0, 0] handling negative numbers and zero"
      },
      {
        "input": {
          "nums": [2, 3, 4, 5]
        },
        "expected": [60, 40, 30, 24],
        "description": "should return [60, 40, 30, 24] for consecutive integer sequence"
      }
    ]
  },
  "three_sum": {
    "title": "Three Sum",
    "description": "Design an algorithm to identify all unique triplets within an integer array that sum to zero. Given an array of integers, return all distinct combinations of three elements where the sum equals zero and no indices are repeated. The solution must eliminate duplicate triplets from the result set. Implement an efficient approach that can handle arrays with up to 3000 elements containing values ranging from -10^5 to 10^5.",
    "complexity": "O(nÂ²)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers to find triplets within"
      }
    ],
    "returnType": {
      "javascript": "array<array<integer>>",
      "ruby": "array<array<integer>>",
      "python": "list<list<integer>>"
    },
    "functionSignatures": {
      "javascript": "function threeSum(nums)",
      "ruby": "def three_sum(nums)",
      "python": "def three_sum(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [-1, 0, 1, 2, -1, -4]
        },
        "expected": [[-1, -1, 2], [-1, 0, 1]],
        "description": "should return [[-1, -1, 2], [-1, 0, 1]] for mixed positive and negative values",
        "comparison": {
          "mode": "unordered_array",
          "type": "deep_equality"
        }
      },
      {
        "input": {
          "nums": [0, 1, 1]
        },
        "expected": [],
        "description": "should return empty array when no valid triplets exist"
      },
      {
        "input": {
          "nums": [0, 0, 0]
        },
        "expected": [[0, 0, 0]],
        "description": "should return [[0, 0, 0]] for array of all zeros"
      }
    ]
  },
  "merge_intervals": {
    "title": "Merge Intervals",
    "description": "Construct an algorithm to consolidate overlapping intervals within a collection. Given an array of intervals where each interval is represented as [start, end], merge all overlapping intervals and return an array of non-overlapping intervals that cover the entire input range. Two intervals are considered overlapping if they share any common points, including when one interval's end equals another's start. Design an efficient solution that can handle up to 10^4 intervals with coordinates ranging from 0 to 10^4.",
    "complexity": "O(n log n)",
    "parameters": [
      {
        "name": "intervals",
        "type": "array<array<integer>>",
        "description": "Array of intervals where each interval is [start, end]"
      }
    ],
    "returnType": {
      "javascript": "array<array<integer>>",
      "ruby": "array<array<integer>>",
      "python": "list<list<integer>>"
    },
    "functionSignatures": {
      "javascript": "function merge(intervals)",
      "ruby": "def merge(intervals)",
      "python": "def merge(intervals)"
    },
    "testCases": [
      {
        "input": {
          "intervals": [[1, 3], [2, 6], [8, 10], [15, 18]]
        },
        "expected": [[1, 6], [8, 10], [15, 18]],
        "description": "should merge overlapping intervals [1,3] and [2,6] into [1,6]"
      },
      {
        "input": {
          "intervals": [[1, 4], [4, 5]]
        },
        "expected": [[1, 5]],
        "description": "should merge touching intervals [1,4] and [4,5] into [1,5]"
      },
      {
        "input": {
          "intervals": [[4, 7], [1, 4]]
        },
        "expected": [[1, 7]],
        "description": "should merge overlapping intervals after sorting [4,7] and [1,4] into [1,7]"
      }
    ]
  },
  "group_anagrams": {
    "title": "Group Anagrams",
    "description": "Develop an algorithm to categorize strings into groups where each group contains anagrams of each other. Given an array of strings, identify and collect all strings that can be rearranged to form identical character sequences. Two strings are anagrams if they contain exactly the same characters with the same frequencies, but potentially in different orders. Return the grouped anagrams in any arrangement. Design an efficient solution that can process up to 10^4 strings, each containing up to 100 lowercase English letters.",
    "complexity": "O(n * k log k)",
    "parameters": [
      {
        "name": "strs",
        "type": "array<string>",
        "description": "Array of strings to group by anagrams"
      }
    ],
    "returnType": {
      "javascript": "array<array<string>>",
      "ruby": "array<array<string>>",
      "python": "list<list<string>>"
    },
    "functionSignatures": {
      "javascript": "function groupAnagrams(strs)",
      "ruby": "def group_anagrams(strs)",
      "python": "def group_anagrams(strs)"
    },
    "testCases": [
      {
        "input": {
          "strs": ["eat", "tea", "tan", "ate", "nat", "bat"]
        },
        "expected": [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]],
        "description": "should group anagrams correctly with mixed groups",
        "comparison": {
          "mode": "unordered_array",
          "type": "deep_equality"
        }
      },
      {
        "input": {
          "strs": [""]
        },
        "expected": [[""]],
        "description": "should handle single empty string"
      },
      {
        "input": {
          "strs": ["a"]
        },
        "expected": [["a"]],
        "description": "should handle single character string"
      }
    ]
  },
  "reverse_linked_list": {
    "title": "Reverse Linked List",
    "description": "Implement an algorithm to reverse a singly linked list by modifying the direction of node connections. Given the head node of a linked list, rearrange the pointers so that the list traversal order is completely inverted. The original head becomes the tail, and the original tail becomes the new head. Design both iterative and recursive approaches to solve this fundamental linked list manipulation problem. Handle edge cases including empty lists and single-node lists. The solution should operate within the constraints of 0 to 5000 nodes with values ranging from -5000 to 5000.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "head",
        "type": "ListNode",
        "description": "Head node of the singly linked list to reverse"
      }
    ],
    "returnType": {
      "javascript": "ListNode",
      "ruby": "ListNode",
      "python": "ListNode"
    },
    "functionSignatures": {
      "javascript": "function reverseList(head)",
      "ruby": "def reverse_list(head)",
      "python": "def reverse_list(head)"
    },
    "testCases": [
      {
        "input": {
          "head": [1, 2, 3, 4, 5]
        },
        "expected": [5, 4, 3, 2, 1],
        "description": "should reverse a 5-node list from [1,2,3,4,5] to [5,4,3,2,1]"
      },
      {
        "input": {
          "head": [1, 2]
        },
        "expected": [2, 1],
        "description": "should reverse a 2-node list from [1,2] to [2,1]"
      },
      {
        "input": {
          "head": []
        },
        "expected": [],
        "description": "should handle empty list and return empty list"
      }
    ]
  },
  "has_cycle": {
    "title": "Detect Cycle in Linked List",
    "description": "Implement an algorithm to determine whether a singly linked list contains a cycle. Given the head node of a linked list, detect if there exists a cycle where some node in the list can be reached again by continuously following the next pointer. The challenge is to solve this using optimal O(1) constant memory space complexity. Consider implementing Floyd's Cycle-Finding Algorithm (tortoise and hare approach) for an elegant solution. Handle edge cases including empty lists and single-node lists. The solution should efficiently process lists with up to 10^4 nodes containing values from -10^5 to 10^5.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "head",
        "type": "ListNode",
        "description": "Head node of the singly linked list to check for cycles"
      }
    ],
    "returnType": {
      "javascript": "boolean",
      "ruby": "boolean",
      "python": "boolean"
    },
    "functionSignatures": {
      "javascript": "function hasCycle(head)",
      "ruby": "def has_cycle(head)",
      "python": "def has_cycle(head)"
    },
    "testCases": [
      {
        "input": {
          "head": [3, 2, 0, -4],
          "pos": 1
        },
        "expected": true,
        "description": "should return true when tail connects to 1st node (0-indexed)"
      },
      {
        "input": {
          "head": [1, 2],
          "pos": 0
        },
        "expected": true,
        "description": "should return true when tail connects to 0th node"
      },
      {
        "input": {
          "head": [1],
          "pos": -1
        },
        "expected": false,
        "description": "should return false for single node with no cycle"
      },
      {
        "input": {
          "head": [],
          "pos": -1
        },
        "expected": false,
        "description": "should return false for empty list"
      }
    ]
  },
  "container_with_most_water": {
    "title": "Container With Most Water",
    "description": "Design an algorithm to find two vertical lines that together with the x-axis form a container capable of holding the maximum amount of water. Given an integer array representing the height of n vertical lines drawn at positions (i, 0) to (i, height[i]), determine the optimal pair of lines that maximizes the water volume. The container's capacity is determined by the shorter of the two selected lines multiplied by the distance between them. Note that the container cannot be tilted. Implement an efficient solution that can handle arrays with up to 10^5 elements containing heights from 0 to 10^4.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "height",
        "type": "array<integer>",
        "description": "Array of integers representing the height of vertical lines"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function maxArea(height)",
      "ruby": "def max_area(height)",
      "python": "def max_area(height)"
    },
    "testCases": [
      {
        "input": {
          "height": [1, 8, 6, 2, 5, 4, 8, 3, 7]
        },
        "expected": 49,
        "description": "should return 49 as the maximum water area"
      },
      {
        "input": {
          "height": [1, 1]
        },
        "expected": 1,
        "description": "should return 1 for two lines of equal height"
      },
      {
        "input": {
          "height": [4, 3, 2, 1, 4]
        },
        "expected": 16,
        "description": "should return 16 using the first and last lines"
      },
      {
        "input": {
          "height": [1, 2, 1]
        },
        "expected": 2,
        "description": "should return 2 using the first and last lines"
      }
    ]
  },
  "find_minimum_in_rotated_sorted_array": {
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "Implement a binary search algorithm to locate the minimum element in a rotated sorted array of unique integers. Consider an initially sorted array that has been rotated between 1 and n times, where rotation involves moving elements from the end to the beginning. The challenge is to identify the pivot point where the rotation occurred, which corresponds to the minimum element. Design an efficient logarithmic time solution using modified binary search that can handle arrays with up to 5000 elements containing values from -5000 to 5000. The algorithm must achieve O(log n) time complexity by leveraging the partial ordering properties of the rotated array.",
    "complexity": "O(log n)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Rotated sorted array of unique integers"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function findMin(nums)",
      "ruby": "def find_min(nums)",
      "python": "def find_min(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [3, 4, 5, 1, 2]
        },
        "expected": 1,
        "description": "should return 1 from rotated array [3,4,5,1,2]"
      },
      {
        "input": {
          "nums": [4, 5, 6, 7, 0, 1, 2]
        },
        "expected": 0,
        "description": "should return 0 from rotated array [4,5,6,7,0,1,2]"
      },
      {
        "input": {
          "nums": [11, 13, 15, 17]
        },
        "expected": 11,
        "description": "should return 11 from non-rotated array [11,13,15,17]"
      },
      {
        "input": {
          "nums": [2, 1]
        },
        "expected": 1,
        "description": "should return 1 from small rotated array [2,1]"
      },
      {
        "input": {
          "nums": [1]
        },
        "expected": 1,
        "description": "should return 1 from single element array [1]"
      }
    ]
  },
  "longest_repeating_character_replacement": {
    "title": "Longest Repeating Character Replacement",
    "description": "Develop a sliding window algorithm to determine the maximum length of a substring containing identical characters that can be achieved through strategic character replacements. Given a string of uppercase English letters and a limit k on the number of character modifications allowed, implement an efficient solution that finds the optimal substring where all characters can be made identical using at most k replacements. The algorithm should employ a two-pointer technique with frequency tracking to maintain a valid window and maximize the resulting substring length. Design the solution to handle strings with up to 10^5 characters efficiently.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "s",
        "type": "string",
        "description": "String consisting of only uppercase English letters"
      },
      {
        "name": "k",
        "type": "integer",
        "description": "Maximum number of character replacements allowed"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function characterReplacement(s, k)",
      "ruby": "def character_replacement(s, k)",
      "python": "def character_replacement(s, k)"
    },
    "testCases": [
      {
        "input": {
          "s": "ABAB",
          "k": 2
        },
        "expected": 4,
        "description": "should return 4 by replacing two 'A's with 'B's or vice versa"
      },
      {
        "input": {
          "s": "AABABBA",
          "k": 1
        },
        "expected": 4,
        "description": "should return 4 by replacing one 'A' to form substring 'BBBB'"
      },
      {
        "input": {
          "s": "ABCDE",
          "k": 1
        },
        "expected": 2,
        "description": "should return 2 since we can make any 2 consecutive chars the same"
      },
      {
        "input": {
          "s": "AAAA",
          "k": 0
        },
        "expected": 4,
        "description": "should return 4 since all characters are already the same"
      },
      {
        "input": {
          "s": "ABAB",
          "k": 0
        },
        "expected": 1,
        "description": "should return 1 since no replacements allowed"
      }
    ]
  },
  "longest_substring_without_repeating_characters": {
    "title": "Longest Substring Without Repeating Characters",
    "description": "Implement a sliding window algorithm to determine the maximum length of a substring that contains no duplicate characters. Given a string consisting of English letters, digits, symbols, and spaces, design an efficient solution that identifies the longest contiguous sequence where each character appears at most once. The algorithm should employ a two-pointer technique with a hash set or hash map to track character occurrences within the current window. Optimize the solution to handle strings with up to 50,000 characters efficiently by dynamically adjusting the window boundaries when duplicates are encountered.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "s",
        "type": "string",
        "description": "String consisting of English letters, digits, symbols and spaces"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function lengthOfLongestSubstring(s)",
      "ruby": "def length_of_longest_substring(s)",
      "python": "def length_of_longest_substring(s)"
    },
    "testCases": [
      {
        "input": {
          "s": "abcabcbb"
        },
        "expected": 3,
        "description": "should return 3 for substring 'abc'"
      },
      {
        "input": {
          "s": "bbbbb"
        },
        "expected": 1,
        "description": "should return 1 for substring 'b'"
      },
      {
        "input": {
          "s": "pwwkew"
        },
        "expected": 3,
        "description": "should return 3 for substring 'wke'"
      },
      {
        "input": {
          "s": ""
        },
        "expected": 0,
        "description": "should return 0 for empty string"
      },
      {
        "input": {
          "s": " "
        },
        "expected": 1,
        "description": "should return 1 for single space character"
      },
      {
        "input": {
          "s": "au"
        },
        "expected": 2,
        "description": "should return 2 for two distinct characters"
      }
    ]
  },
  "number_of_islands": {
    "title": "Number of Islands",
    "description": "Implement a graph traversal algorithm to count the number of distinct islands in a 2D binary grid. Given an m x n matrix where '1' represents land and '0' represents water, determine how many separate landmasses exist. An island is defined as a group of adjacent land cells connected horizontally or vertically, surrounded by water. Design an efficient solution using depth-first search (DFS) or breadth-first search (BFS) to explore and mark visited land cells. The algorithm should handle grids with up to 300x300 dimensions and assume all grid edges are surrounded by water.",
    "complexity": "O(m*n)",
    "parameters": [
      {
        "name": "grid",
        "type": "array<array<string>>",
        "description": "2D binary grid where '1' represents land and '0' represents water"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function numIslands(grid)",
      "ruby": "def num_islands(grid)",
      "python": "def num_islands(grid)"
    },
    "testCases": [
      {
        "input": {
          "grid": [
            ["1", "1", "1", "1", "0"],
            ["1", "1", "0", "1", "0"],
            ["1", "1", "0", "0", "0"],
            ["0", "0", "0", "0", "0"]
          ]
        },
        "expected": 1,
        "description": "should return 1 for a single connected island"
      },
      {
        "input": {
          "grid": [
            ["1", "1", "0", "0", "0"],
            ["1", "1", "0", "0", "0"],
            ["0", "0", "1", "0", "0"],
            ["0", "0", "0", "1", "1"]
          ]
        },
        "expected": 3,
        "description": "should return 3 for three separate islands"
      },
      {
        "input": {
          "grid": [
            ["1", "0", "1", "1", "1"],
            ["1", "0", "1", "0", "1"],
            ["1", "1", "1", "0", "1"]
          ]
        },
        "expected": 1,
        "description": "should return 1 for one large connected island"
      },
      {
        "input": {
          "grid": [
            ["0", "0", "0", "0"],
            ["0", "0", "0", "0"],
            ["0", "0", "0", "0"]
          ]
        },
        "expected": 0,
        "description": "should return 0 for grid with no land"
      },
      {
        "input": {
          "grid": [
            ["1"]
          ]
        },
        "expected": 1,
        "description": "should return 1 for single land cell"
      }
    ]
  },
  "remove_nth_from_end": {
    "title": "Remove Nth Node From End of List",
    "description": "Implement an algorithm to remove the nth node from the end of a singly linked list and return the modified list's head. Design an efficient one-pass solution using the two-pointer technique, where one pointer advances n steps ahead of the other to maintain the correct distance. This approach eliminates the need to first calculate the list length. Handle edge cases including removing the head node and working with lists containing only one element. The solution should process linked lists with up to 30 nodes containing values from 0 to 100.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "head",
        "type": "ListNode",
        "description": "Head node of the singly linked list"
      },
      {
        "name": "n",
        "type": "integer",
        "description": "Position from the end of the list (1-indexed)"
      }
    ],
    "returnType": {
      "javascript": "ListNode",
      "ruby": "ListNode",
      "python": "ListNode"
    },
    "functionSignatures": {
      "javascript": "function removeNthFromEnd(head, n)",
      "ruby": "def remove_nth_from_end(head, n)",
      "python": "def remove_nth_from_end(head, n)"
    },
    "testCases": [
      {
        "input": {
          "head": [1, 2, 3, 4, 5],
          "n": 2
        },
        "expected": [1, 2, 3, 5],
        "description": "should remove 2nd node from end [1,2,3,4,5] -> [1,2,3,5]"
      },
      {
        "input": {
          "head": [1],
          "n": 1
        },
        "expected": [],
        "description": "should remove only node [1] -> []"
      },
      {
        "input": {
          "head": [1, 2],
          "n": 1
        },
        "expected": [1],
        "description": "should remove last node [1,2] -> [1]"
      },
      {
        "input": {
          "head": [1, 2],
          "n": 2
        },
        "expected": [2],
        "description": "should remove first node [1,2] -> [2]"
      },
      {
        "input": {
          "head": [1, 2, 3, 4, 5],
          "n": 5
        },
        "expected": [2, 3, 4, 5],
        "description": "should remove first node [1,2,3,4,5] -> [2,3,4,5]"
      }
    ]
  },
  "palindromic_substrings": {
    "title": "Palindromic Substrings",
    "description": "Develop an algorithm to count the total number of palindromic substrings within a given string. A palindrome is defined as a sequence that reads identically in both forward and reverse directions. A substring represents any contiguous sequence of characters from the original string. Implement an efficient solution using the expand-around-centers technique, which examines each possible center point (including positions between characters for even-length palindromes) and expands outward while characters match. Design the algorithm to handle strings with up to 1000 lowercase English letters optimally.",
    "complexity": "O(n^2)",
    "parameters": [
      {
        "name": "s",
        "type": "string",
        "description": "String consisting of lowercase English letters"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function countSubstrings(s)",
      "ruby": "def count_substrings(s)",
      "python": "def count_substrings(s)"
    },
    "testCases": [
      {
        "input": {
          "s": "abc"
        },
        "expected": 3,
        "description": "should return 3 for palindromes 'a', 'b', 'c'"
      },
      {
        "input": {
          "s": "aaa"
        },
        "expected": 6,
        "description": "should return 6 for palindromes 'a', 'a', 'a', 'aa', 'aa', 'aaa'"
      },
      {
        "input": {
          "s": "aba"
        },
        "expected": 4,
        "description": "should return 4 for palindromes 'a', 'b', 'a', 'aba'"
      },
      {
        "input": {
          "s": "racecar"
        },
        "expected": 10,
        "description": "should return 10 for all palindromic substrings in 'racecar'"
      },
      {
        "input": {
          "s": "a"
        },
        "expected": 1,
        "description": "should return 1 for single character 'a'"
      },
      {
        "input": {
          "s": "abcba"
        },
        "expected": 7,
        "description": "should return 7 for palindromes including 'bcb' and 'abcba'"
      }
    ]
  },
  "pacific_atlantic_water_flow": {
    "title": "Pacific Atlantic Water Flow",
    "description": "Design an algorithm to identify grid coordinates where rainwater can reach both Pacific and Atlantic oceans through elevation-based flow. Given an m x n matrix representing island heights, where the Pacific Ocean borders the left and top edges while the Atlantic Ocean borders the right and bottom edges, determine all cells from which water can flow to both oceans. Water flows from higher to lower or equal elevation cells in four cardinal directions. Implement an efficient solution using depth-first search (DFS) from ocean boundaries, working backwards to identify reachable cells. The algorithm should handle grids up to 200x200 with elevations from 0 to 10^5.",
    "complexity": "O(m*n)",
    "parameters": [
      {
        "name": "heights",
        "type": "array<array<integer>>",
        "description": "2D matrix where heights[r][c] represents elevation of cell (r,c)"
      }
    ],
    "returnType": {
      "javascript": "array<array<integer>>",
      "ruby": "array<array<integer>>",
      "python": "list<list<integer>>"
    },
    "functionSignatures": {
      "javascript": "function pacificAtlantic(heights)",
      "ruby": "def pacific_atlantic(heights)",
      "python": "def pacific_atlantic(heights)"
    },
    "testCases": [
      {
        "input": {
          "heights": [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]
        },
        "expected": [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]],
        "description": "should return coordinates reachable by both oceans",
        "comparison": {
          "mode": "unordered_array",
          "type": "deep_equality"
        }
      },
      {
        "input": {
          "heights": [[1]]
        },
        "expected": [[0, 0]],
        "description": "should return [0,0] for single cell touching both oceans"
      },
      {
        "input": {
          "heights": [[1, 2], [2, 1]]
        },
        "expected": [[0, 0], [0, 1], [1, 0], [1, 1]],
        "description": "should return all cells for 2x2 grid",
        "comparison": {
          "mode": "unordered_array",
          "type": "deep_equality"
        }
      },
      {
        "input": {
          "heights": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
        },
        "expected": [[0, 2], [1, 2], [2, 0], [2, 1], [2, 2]],
        "description": "should return corner and edge cells for increasing heights",
        "comparison": {
          "mode": "unordered_array",
          "type": "deep_equality"
        }
      }
    ]
  },
  "minimum_window_substring": {
    "title": "Minimum Window Substring",
    "description": "Implement an advanced sliding window algorithm to find the minimum window substring that contains all characters from a target string. Given two strings s and t, where s has length m and t has length n, identify the shortest contiguous substring of s that includes every character from t with the correct frequency counts. The algorithm must handle duplicate characters appropriately and return an empty string if no valid window exists. Design an optimal solution using the two-pointer sliding window technique with hash maps for character frequency tracking. The solution should achieve O(m + n) time complexity and handle strings with up to 10^5 characters consisting of uppercase and lowercase English letters.",
    "complexity": "O(m + n)",
    "parameters": [
      {
        "name": "s",
        "type": "string",
        "description": "Source string of length m consisting of English letters"
      },
      {
        "name": "t",
        "type": "string",
        "description": "Target string of length n consisting of English letters"
      }
    ],
    "returnType": {
      "javascript": "string",
      "ruby": "string",
      "python": "string"
    },
    "functionSignatures": {
      "javascript": "function minWindow(s, t)",
      "ruby": "def min_window(s, t)",
      "python": "def min_window(s, t)"
    },
    "testCases": [
      {
        "input": {
          "s": "ADOBECODEBANC",
          "t": "ABC"
        },
        "expected": "BANC",
        "description": "should return 'BANC' as the minimum window containing all characters"
      },
      {
        "input": {
          "s": "a",
          "t": "a"
        },
        "expected": "a",
        "description": "should return entire string when it matches target"
      },
      {
        "input": {
          "s": "a",
          "t": "aa"
        },
        "expected": "",
        "description": "should return empty string when target has more characters than source"
      },
      {
        "input": {
          "s": "ab",
          "t": "b"
        },
        "expected": "b",
        "description": "should return single character when it's the only requirement"
      },
      {
        "input": {
          "s": "abc",
          "t": "cba"
        },
        "expected": "abc",
        "description": "should return entire string when all characters are needed"
      },
      {
        "input": {
          "s": "ADOBECODEBANC",
          "t": "AABC"
        },
        "expected": "ADOBECODEBA",
        "description": "should handle duplicate characters correctly"
      }
    ]
  }
}