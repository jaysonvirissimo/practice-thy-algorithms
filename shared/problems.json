{
  "two_sum": {
    "title": "Two Sum",
    "description": "Implement a function that locates a pair of elements within an integer array whose sum equals a specified target value. The function should return the array indices of these two elements. Assume exactly one valid pair exists and that no element may be used twice in the solution.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "array",
        "type": "array<integer>",
        "description": "Array of integers"
      },
      {
        "name": "target",
        "type": "integer",
        "description": "Target sum"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function twoSum(nums, target)",
      "ruby": "def two_sum(nums, target)",
      "python": "def two_sum(nums, target)"
    },
    "testCases": [
      {
        "input": {
          "nums": [2, 7, 11, 15],
          "target": 9
        },
        "expected": [0, 1],
        "description": "should return indices [0, 1] because nums[0] + nums[1] = 2 + 7 = 9"
      },
      {
        "input": {
          "nums": [3, 2, 4],
          "target": 6
        },
        "expected": [1, 2],
        "description": "should return indices [1, 2] because nums[1] + nums[2] = 2 + 4 = 6"
      },
      {
        "input": {
          "nums": [3, 3],
          "target": 6
        },
        "expected": [0, 1],
        "description": "should return indices [0, 1] because nums[0] + nums[1] = 3 + 3 = 6"
      }
    ]
  },
  "maximum_subarray": {
    "title": "Maximum Subarray",
    "description": "Design an algorithm to determine the maximum sum achievable from any contiguous subsequence within an array of integers. The array contains both positive and negative values. While a brute-force approach examining all possible subarrays runs in O(n²) time, strive for an optimal O(n) solution using constant space.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "array",
        "type": "array<integer>",
        "description": "Array of integers (positive and negative)"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function maximumSubarray(numbers)",
      "ruby": "def maximum_subarray(array)",
      "python": "def maximum_subarray(array)"
    },
    "testCases": [
      {
        "input": {
          "array": [4, -1, 5, 6, -13, 2]
        },
        "expected": 14,
        "description": "should return the largest subsum"
      },
      {
        "input": {
          "array": [-2, 1, -3, 4, -1, 2, 1, -5, 4]
        },
        "expected": 6,
        "description": "should return the largest subsum"
      }
    ]
  },
  "unique_paths": {
    "title": "Unique Paths",
    "description": "Develop a recursive algorithm to count the total number of distinct shortest paths through a rectangular grid from the top-left corner to the bottom-right corner. Movement is restricted to rightward and downward steps only. Implement memoization to optimize the recursive solution and avoid redundant calculations.",
    "complexity": "O(m*n)",
    "parameters": [
      {
        "name": "rows",
        "type": "integer",
        "description": "Number of rows in the grid"
      },
      {
        "name": "columns",
        "type": "integer",
        "description": "Number of columns in the grid"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function uniquePaths(rows, columns)",
      "ruby": "def unique_paths(rows, columns)",
      "python": "def unique_paths(rows, columns)"
    },
    "testCases": [
      {
        "input": {
          "rows": 3,
          "columns": 7
        },
        "expected": 28,
        "description": "should return 28 unique paths for 3x7 grid"
      },
      {
        "input": {
          "rows": 4,
          "columns": 12
        },
        "expected": 364,
        "description": "should return 364 unique paths for 4x12 grid"
      },
      {
        "input": {
          "rows": 5,
          "columns": 15
        },
        "expected": 3060,
        "description": "should return 3060 unique paths for 5x15 grid"
      }
    ]
  },
  "coin_change": {
    "title": "Coin Change",
    "description": "Construct an algorithm that determines the minimum number of coins needed to make change for a given monetary amount. Given a set of coin denominations and a target amount, return an array containing the specific coins that sum to the target using the fewest possible coins. Implement this as a classic dynamic programming optimization problem.",
    "complexity": "O(amount * coins)",
    "parameters": [
      {
        "name": "amount",
        "type": "integer",
        "description": "Target monetary amount to make change for"
      },
      {
        "name": "coins",
        "type": "array<integer>",
        "description": "Available coin denominations (optional, defaults to [1, 5, 10, 25])"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function coinChange(amount, coins = [1, 5, 10, 25])",
      "ruby": "def coin_change(amount, coins = [1, 5, 10, 25])",
      "python": "def coin_change(amount, coins = [1, 5, 10, 25])"
    },
    "testCases": [
      {
        "input": {
          "amount": 36,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 10, 1],
        "description": "should return [25, 10, 1] using minimum 3 coins for 36 cents"
      },
      {
        "input": {
          "amount": 43,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 10, 5, 1, 1, 1],
        "description": "should return [25, 10, 5, 1, 1, 1] using minimum 6 coins for 43 cents"
      },
      {
        "input": {
          "amount": 67,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 25, 10, 5, 1, 1],
        "description": "should return [25, 25, 10, 5, 1, 1] using minimum 6 coins for 67 cents"
      }
    ]
  },
  "contains_duplicate": {
    "title": "Contains Duplicate",
    "description": "Analyze an integer array to determine whether any value appears more than once. Return true if at least one duplicate exists, false if all elements are distinct. Design an efficient solution that can handle arrays with up to 100,000 elements containing values in the range of negative one billion to positive one billion.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers to check for duplicates"
      }
    ],
    "returnType": {
      "javascript": "boolean",
      "ruby": "boolean",
      "python": "boolean"
    },
    "functionSignatures": {
      "javascript": "function containsDuplicate(nums)",
      "ruby": "def contains_duplicate(nums)",
      "python": "def contains_duplicate(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [1, 2, 3, 1]
        },
        "expected": true,
        "description": "should return true when element 1 appears at indices 0 and 3"
      },
      {
        "input": {
          "nums": [1, 2, 3, 4]
        },
        "expected": false,
        "description": "should return false when all elements are distinct"
      },
      {
        "input": {
          "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
        },
        "expected": true,
        "description": "should return true when multiple elements have duplicates"
      }
    ]
  },
  "best_time_to_buy_and_sell_stock": {
    "title": "Best Time to Buy and Sell Stock",
    "description": "Determine the optimal strategy for a single stock transaction to maximize profit. Given an array representing stock prices over consecutive days, identify the most profitable buy-sell pair where the purchase precedes the sale. The algorithm should find the maximum difference between a selling price and a buying price, with the constraint that the buying day must occur before the selling day. If no profitable transaction exists, return zero.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "prices",
        "type": "array<integer>",
        "description": "Array of stock prices where prices[i] represents the price on day i"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function maxProfit(prices)",
      "ruby": "def max_profit(prices)",
      "python": "def max_profit(prices)"
    },
    "testCases": [
      {
        "input": {
          "prices": [7, 1, 5, 3, 6, 4]
        },
        "expected": 5,
        "description": "should return 5 by buying at price 1 and selling at price 6"
      },
      {
        "input": {
          "prices": [7, 6, 4, 3, 1]
        },
        "expected": 0,
        "description": "should return 0 when prices only decrease"
      },
      {
        "input": {
          "prices": [1, 2, 3, 4, 5]
        },
        "expected": 4,
        "description": "should return 4 by buying at price 1 and selling at price 5"
      }
    ]
  },
  "valid_parentheses": {
    "title": "Valid Parentheses",
    "description": "Construct an algorithm to validate the proper matching and ordering of bracket characters within a string. Given a string containing only parentheses, square brackets, and curly braces, determine whether the brackets are correctly paired and nested. Each opening bracket must have a corresponding closing bracket of the same type, and brackets must be closed in the proper order to maintain valid nesting structure.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "s",
        "type": "string",
        "description": "String containing only bracket characters: '(', ')', '[', ']', '{', '}'"
      }
    ],
    "returnType": {
      "javascript": "boolean",
      "ruby": "boolean",
      "python": "boolean"
    },
    "functionSignatures": {
      "javascript": "function isValid(s)",
      "ruby": "def is_valid(s)",
      "python": "def is_valid(s)"
    },
    "testCases": [
      {
        "input": {
          "s": "()"
        },
        "expected": true,
        "description": "should return true for simple parentheses pair"
      },
      {
        "input": {
          "s": "()[]{}"
        },
        "expected": true,
        "description": "should return true for multiple bracket types in sequence"
      },
      {
        "input": {
          "s": "(]"
        },
        "expected": false,
        "description": "should return false for mismatched bracket types"
      },
      {
        "input": {
          "s": "([])"
        },
        "expected": true,
        "description": "should return true for properly nested brackets"
      },
      {
        "input": {
          "s": "([)]"
        },
        "expected": false,
        "description": "should return false for improperly nested brackets"
      }
    ]
  },
  "product_of_array_except_self": {
    "title": "Product of Array Except Self",
    "description": "Construct an algorithm that generates an output array where each element represents the product of all input array elements excluding the element at the current index position. The solution must operate in O(n) time complexity without utilizing division operations. Design the algorithm to handle arrays containing up to 10^5 elements with values ranging from -30 to 30, ensuring all intermediate and final products remain within 32-bit integer bounds.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers where each element contributes to products at other indices"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function productExceptSelf(nums)",
      "ruby": "def product_except_self(nums)",
      "python": "def product_except_self(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [1, 2, 3, 4]
        },
        "expected": [24, 12, 8, 6],
        "description": "should return [24, 12, 8, 6] where each element is the product of all others"
      },
      {
        "input": {
          "nums": [-1, 1, 0, -3, 3]
        },
        "expected": [0, 0, 9, 0, 0],
        "description": "should return [0, 0, 9, 0, 0] handling negative numbers and zero"
      },
      {
        "input": {
          "nums": [2, 3, 4, 5]
        },
        "expected": [60, 40, 30, 24],
        "description": "should return [60, 40, 30, 24] for consecutive integer sequence"
      }
    ]
  },
  "three_sum": {
    "title": "Three Sum",
    "description": "Design an algorithm to identify all unique triplets within an integer array that sum to zero. Given an array of integers, return all distinct combinations of three elements where the sum equals zero and no indices are repeated. The solution must eliminate duplicate triplets from the result set. Implement an efficient approach that can handle arrays with up to 3000 elements containing values ranging from -10^5 to 10^5.",
    "complexity": "O(n²)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers to find triplets within"
      }
    ],
    "returnType": {
      "javascript": "array<array<integer>>",
      "ruby": "array<array<integer>>",
      "python": "list<list<integer>>"
    },
    "functionSignatures": {
      "javascript": "function threeSum(nums)",
      "ruby": "def three_sum(nums)",
      "python": "def three_sum(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [-1, 0, 1, 2, -1, -4]
        },
        "expected": [[-1, -1, 2], [-1, 0, 1]],
        "description": "should return [[-1, -1, 2], [-1, 0, 1]] for mixed positive and negative values"
      },
      {
        "input": {
          "nums": [0, 1, 1]
        },
        "expected": [],
        "description": "should return empty array when no valid triplets exist"
      },
      {
        "input": {
          "nums": [0, 0, 0]
        },
        "expected": [[0, 0, 0]],
        "description": "should return [[0, 0, 0]] for array of all zeros"
      }
    ]
  },
  "merge_intervals": {
    "title": "Merge Intervals",
    "description": "Construct an algorithm to consolidate overlapping intervals within a collection. Given an array of intervals where each interval is represented as [start, end], merge all overlapping intervals and return an array of non-overlapping intervals that cover the entire input range. Two intervals are considered overlapping if they share any common points, including when one interval's end equals another's start. Design an efficient solution that can handle up to 10^4 intervals with coordinates ranging from 0 to 10^4.",
    "complexity": "O(n log n)",
    "parameters": [
      {
        "name": "intervals",
        "type": "array<array<integer>>",
        "description": "Array of intervals where each interval is [start, end]"
      }
    ],
    "returnType": {
      "javascript": "array<array<integer>>",
      "ruby": "array<array<integer>>",
      "python": "list<list<integer>>"
    },
    "functionSignatures": {
      "javascript": "function merge(intervals)",
      "ruby": "def merge(intervals)",
      "python": "def merge(intervals)"
    },
    "testCases": [
      {
        "input": {
          "intervals": [[1, 3], [2, 6], [8, 10], [15, 18]]
        },
        "expected": [[1, 6], [8, 10], [15, 18]],
        "description": "should merge overlapping intervals [1,3] and [2,6] into [1,6]"
      },
      {
        "input": {
          "intervals": [[1, 4], [4, 5]]
        },
        "expected": [[1, 5]],
        "description": "should merge touching intervals [1,4] and [4,5] into [1,5]"
      },
      {
        "input": {
          "intervals": [[4, 7], [1, 4]]
        },
        "expected": [[1, 7]],
        "description": "should merge overlapping intervals after sorting [4,7] and [1,4] into [1,7]"
      }
    ]
  },
  "group_anagrams": {
    "title": "Group Anagrams",
    "description": "Develop an algorithm to categorize strings into groups where each group contains anagrams of each other. Given an array of strings, identify and collect all strings that can be rearranged to form identical character sequences. Two strings are anagrams if they contain exactly the same characters with the same frequencies, but potentially in different orders. Return the grouped anagrams in any arrangement. Design an efficient solution that can process up to 10^4 strings, each containing up to 100 lowercase English letters.",
    "complexity": "O(n * k log k)",
    "parameters": [
      {
        "name": "strs",
        "type": "array<string>",
        "description": "Array of strings to group by anagrams"
      }
    ],
    "returnType": {
      "javascript": "array<array<string>>",
      "ruby": "array<array<string>>",
      "python": "list<list<string>>"
    },
    "functionSignatures": {
      "javascript": "function groupAnagrams(strs)",
      "ruby": "def group_anagrams(strs)",
      "python": "def group_anagrams(strs)"
    },
    "testCases": [
      {
        "input": {
          "strs": ["eat", "tea", "tan", "ate", "nat", "bat"]
        },
        "expected": [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]],
        "description": "should group anagrams correctly with mixed groups"
      },
      {
        "input": {
          "strs": [""]
        },
        "expected": [[""]],
        "description": "should handle single empty string"
      },
      {
        "input": {
          "strs": ["a"]
        },
        "expected": [["a"]],
        "description": "should handle single character string"
      }
    ]
  }
}