{
  "two_sum": {
    "title": "Two Sum",
    "description": "Implement a function that locates a pair of elements within an integer array whose sum equals a specified target value. The function should return the array indices of these two elements. Assume exactly one valid pair exists and that no element may be used twice in the solution.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "array",
        "type": "array<integer>",
        "description": "Array of integers"
      },
      {
        "name": "target",
        "type": "integer",
        "description": "Target sum"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function twoSum(nums, target)",
      "ruby": "def two_sum(nums, target)",
      "python": "def two_sum(nums, target)"
    },
    "testCases": [
      {
        "input": {
          "nums": [2, 7, 11, 15],
          "target": 9
        },
        "expected": [0, 1],
        "description": "should return indices [0, 1] because nums[0] + nums[1] = 2 + 7 = 9"
      },
      {
        "input": {
          "nums": [3, 2, 4],
          "target": 6
        },
        "expected": [1, 2],
        "description": "should return indices [1, 2] because nums[1] + nums[2] = 2 + 4 = 6"
      },
      {
        "input": {
          "nums": [3, 3],
          "target": 6
        },
        "expected": [0, 1],
        "description": "should return indices [0, 1] because nums[0] + nums[1] = 3 + 3 = 6"
      }
    ]
  },
  "maximum_subarray": {
    "title": "Maximum Subarray",
    "description": "Design an algorithm to determine the maximum sum achievable from any contiguous subsequence within an array of integers. The array contains both positive and negative values. While a brute-force approach examining all possible subarrays runs in O(nÂ²) time, strive for an optimal O(n) solution using constant space.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "array",
        "type": "array<integer>",
        "description": "Array of integers (positive and negative)"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function maximumSubarray(numbers)",
      "ruby": "def maximum_subarray(array)",
      "python": "def maximum_subarray(array)"
    },
    "testCases": [
      {
        "input": {
          "array": [4, -1, 5, 6, -13, 2]
        },
        "expected": 14,
        "description": "should return the largest subsum"
      },
      {
        "input": {
          "array": [-2, 1, -3, 4, -1, 2, 1, -5, 4]
        },
        "expected": 6,
        "description": "should return the largest subsum"
      }
    ]
  },
  "unique_paths": {
    "title": "Unique Paths",
    "description": "Develop a recursive algorithm to count the total number of distinct shortest paths through a rectangular grid from the top-left corner to the bottom-right corner. Movement is restricted to rightward and downward steps only. Implement memoization to optimize the recursive solution and avoid redundant calculations.",
    "complexity": "O(m*n)",
    "parameters": [
      {
        "name": "rows",
        "type": "integer",
        "description": "Number of rows in the grid"
      },
      {
        "name": "columns",
        "type": "integer",
        "description": "Number of columns in the grid"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function uniquePaths(rows, columns)",
      "ruby": "def unique_paths(rows, columns)",
      "python": "def unique_paths(rows, columns)"
    },
    "testCases": [
      {
        "input": {
          "rows": 3,
          "columns": 7
        },
        "expected": 28,
        "description": "should return 28 unique paths for 3x7 grid"
      },
      {
        "input": {
          "rows": 4,
          "columns": 12
        },
        "expected": 364,
        "description": "should return 364 unique paths for 4x12 grid"
      },
      {
        "input": {
          "rows": 5,
          "columns": 15
        },
        "expected": 3060,
        "description": "should return 3060 unique paths for 5x15 grid"
      }
    ]
  },
  "coin_change": {
    "title": "Coin Change",
    "description": "Construct an algorithm that determines the minimum number of coins needed to make change for a given monetary amount. Given a set of coin denominations and a target amount, return an array containing the specific coins that sum to the target using the fewest possible coins. Implement this as a classic dynamic programming optimization problem.",
    "complexity": "O(amount * coins)",
    "parameters": [
      {
        "name": "amount",
        "type": "integer",
        "description": "Target monetary amount to make change for"
      },
      {
        "name": "coins",
        "type": "array<integer>",
        "description": "Available coin denominations (optional, defaults to [1, 5, 10, 25])"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function coinChange(amount, coins = [1, 5, 10, 25])",
      "ruby": "def coin_change(amount, coins = [1, 5, 10, 25])",
      "python": "def coin_change(amount, coins = [1, 5, 10, 25])"
    },
    "testCases": [
      {
        "input": {
          "amount": 36,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 10, 1],
        "description": "should return [25, 10, 1] using minimum 3 coins for 36 cents"
      },
      {
        "input": {
          "amount": 43,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 10, 5, 1, 1, 1],
        "description": "should return [25, 10, 5, 1, 1, 1] using minimum 6 coins for 43 cents"
      },
      {
        "input": {
          "amount": 67,
          "coins": [1, 5, 10, 25]
        },
        "expected": [25, 25, 10, 5, 1, 1],
        "description": "should return [25, 25, 10, 5, 1, 1] using minimum 6 coins for 67 cents"
      }
    ]
  },
  "contains_duplicate": {
    "title": "Contains Duplicate",
    "description": "Analyze an integer array to determine whether any value appears more than once. Return true if at least one duplicate exists, false if all elements are distinct. Design an efficient solution that can handle arrays with up to 100,000 elements containing values in the range of negative one billion to positive one billion.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers to check for duplicates"
      }
    ],
    "returnType": {
      "javascript": "boolean",
      "ruby": "boolean",
      "python": "boolean"
    },
    "functionSignatures": {
      "javascript": "function containsDuplicate(nums)",
      "ruby": "def contains_duplicate(nums)",
      "python": "def contains_duplicate(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [1, 2, 3, 1]
        },
        "expected": true,
        "description": "should return true when element 1 appears at indices 0 and 3"
      },
      {
        "input": {
          "nums": [1, 2, 3, 4]
        },
        "expected": false,
        "description": "should return false when all elements are distinct"
      },
      {
        "input": {
          "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
        },
        "expected": true,
        "description": "should return true when multiple elements have duplicates"
      }
    ]
  },
  "best_time_to_buy_and_sell_stock": {
    "title": "Best Time to Buy and Sell Stock",
    "description": "Determine the optimal strategy for a single stock transaction to maximize profit. Given an array representing stock prices over consecutive days, identify the most profitable buy-sell pair where the purchase precedes the sale. The algorithm should find the maximum difference between a selling price and a buying price, with the constraint that the buying day must occur before the selling day. If no profitable transaction exists, return zero.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "prices",
        "type": "array<integer>",
        "description": "Array of stock prices where prices[i] represents the price on day i"
      }
    ],
    "returnType": {
      "javascript": "integer",
      "ruby": "integer",
      "python": "integer"
    },
    "functionSignatures": {
      "javascript": "function maxProfit(prices)",
      "ruby": "def max_profit(prices)",
      "python": "def max_profit(prices)"
    },
    "testCases": [
      {
        "input": {
          "prices": [7, 1, 5, 3, 6, 4]
        },
        "expected": 5,
        "description": "should return 5 by buying at price 1 and selling at price 6"
      },
      {
        "input": {
          "prices": [7, 6, 4, 3, 1]
        },
        "expected": 0,
        "description": "should return 0 when prices only decrease"
      },
      {
        "input": {
          "prices": [1, 2, 3, 4, 5]
        },
        "expected": 4,
        "description": "should return 4 by buying at price 1 and selling at price 5"
      }
    ]
  },
  "valid_parentheses": {
    "title": "Valid Parentheses",
    "description": "Construct an algorithm to validate the proper matching and ordering of bracket characters within a string. Given a string containing only parentheses, square brackets, and curly braces, determine whether the brackets are correctly paired and nested. Each opening bracket must have a corresponding closing bracket of the same type, and brackets must be closed in the proper order to maintain valid nesting structure.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "s",
        "type": "string",
        "description": "String containing only bracket characters: '(', ')', '[', ']', '{', '}'"
      }
    ],
    "returnType": {
      "javascript": "boolean",
      "ruby": "boolean",
      "python": "boolean"
    },
    "functionSignatures": {
      "javascript": "function isValid(s)",
      "ruby": "def is_valid(s)",
      "python": "def is_valid(s)"
    },
    "testCases": [
      {
        "input": {
          "s": "()"
        },
        "expected": true,
        "description": "should return true for simple parentheses pair"
      },
      {
        "input": {
          "s": "()[]{}"
        },
        "expected": true,
        "description": "should return true for multiple bracket types in sequence"
      },
      {
        "input": {
          "s": "(]"
        },
        "expected": false,
        "description": "should return false for mismatched bracket types"
      },
      {
        "input": {
          "s": "([])"
        },
        "expected": true,
        "description": "should return true for properly nested brackets"
      },
      {
        "input": {
          "s": "([)]"
        },
        "expected": false,
        "description": "should return false for improperly nested brackets"
      }
    ]
  },
  "product_of_array_except_self": {
    "title": "Product of Array Except Self",
    "description": "Construct an algorithm that generates an output array where each element represents the product of all input array elements excluding the element at the current index position. The solution must operate in O(n) time complexity without utilizing division operations. Design the algorithm to handle arrays containing up to 10^5 elements with values ranging from -30 to 30, ensuring all intermediate and final products remain within 32-bit integer bounds.",
    "complexity": "O(n)",
    "parameters": [
      {
        "name": "nums",
        "type": "array<integer>",
        "description": "Array of integers where each element contributes to products at other indices"
      }
    ],
    "returnType": {
      "javascript": "array<integer>",
      "ruby": "array<integer>",
      "python": "list<integer>"
    },
    "functionSignatures": {
      "javascript": "function productExceptSelf(nums)",
      "ruby": "def product_except_self(nums)",
      "python": "def product_except_self(nums)"
    },
    "testCases": [
      {
        "input": {
          "nums": [1, 2, 3, 4]
        },
        "expected": [24, 12, 8, 6],
        "description": "should return [24, 12, 8, 6] where each element is the product of all others"
      },
      {
        "input": {
          "nums": [-1, 1, 0, -3, 3]
        },
        "expected": [0, 0, 9, 0, 0],
        "description": "should return [0, 0, 9, 0, 0] handling negative numbers and zero"
      },
      {
        "input": {
          "nums": [2, 3, 4, 5]
        },
        "expected": [60, 40, 30, 24],
        "description": "should return [60, 40, 30, 24] for consecutive integer sequence"
      }
    ]
  }
}